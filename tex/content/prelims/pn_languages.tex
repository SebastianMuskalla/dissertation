\documentclass[../../diss.tex]{subfiles}
\begin{document}

\section{Petri net coverability languages}%
\label{Section:PNCovLang}%

In the following, we want to see Petri nets as language-generating devices.
To this end, we equip the transitions with a labeling.

% \begin{definition}
    Formally, a \emph{labeled Petri net} $N = (P,T,\i,\o,\lambda)$ over $\Sigma$ consists of a Petri net $(P,T,\i,\o)$ together with a labeling function $\lambda \colon T \to \Sigma_\eps$.
% \end{definition}
%
A \emph{computation} $M \fire{\sigma} M'$ generates the word $\lambda(\sigma)$.
Here, we see $\lambda$ as a function of type $T^* \to \Sigma^*$, namely as the unique homomorphism obtained by extending $\lambda \colon T \to \Sigma_\eps$.

To obtain a language, we equip a net with an initial marking and a set of final markings.
Here, we will only consider so-called \emph{coverability languages}, where the set of final markings is the set of markings greater or equal to a specified marking.
Formally, the  \emph{coverability language} of a labeled Petri net instance $(N,\Minit,\Mfinal)$ is
\[
    \lang{N,\Minit,\Mfinal} = \Set{ \lambda(\sigma) }{ \Minit \fire{\sigma} M \geq \Mfinal }
    \ .
\]

Petri net coverability languages are strictly less expressive than Petri net reachability languages (which are defined similarly, but the acceptance condition is reaching precisely the specified marking).
For example, $\Set{a^n b^n}{ n \in \N}$ is a reachability language, but not a coverability language, see \cref{Section:WSTS}.
The reason for studying coverability languages is that coverability is sufficient to express the desired behavior in many cases (see above), and that any algorithmic problem for Petri net reachability languages inherits the intractability of $\PNREACH$.

\begin{example}%
\label{Example:RegularPNCOV}%
    Note that any NFA can be seen as a labeled Petri net instance:
    The places are the states of the automaton, the initial marking puts a single token on the initial state and no token elsewhere.
    The idea is that at each point in time, there is a unique place that carries a single token.
    The transitions are essentially the transitions of the automaton, which specifies their incoming and outgoing multiplicities and their labels.
    We add a special final place and for each final state of the NFA an $\eps$-labeled transition that consumes a token on that state and produces one on the final place.
    The final marking requires a token on the final place.
\end{example}

Hence, the Petri net coverability languages are a superset of the regular languages.
To see that the inclusion is strict, one can show that the non-regular language $\Set{ a^n b^m}{ n,m \in \N, m \leq n }$ can be generated by a Petri net.

%
\cheatpagebreak
%

\paragraph{Algorithmic problems for coverability languages}

The emptiness problem for Petri net coverability languages is the following problem.

\begin{problem}
    \problemtitle{Emptiness problem for Petri net coverability languages}
    \problemshort{($\EMPTYPNCOV$)}
    \probleminput{Labeled Petri net instance $(N, \Minit, \Mfinal)$ over $\Sigma$.}
    \problemquestion{$\lang{N,\Minit,\Mfinal} = \emptyset$?}
\end{problem}

Obviously, a labeled Petri net instance $(N, \Minit, \Mfinal)$ has non-empty language if and only if $\Mfinal$ is coverable from $\Minit$ in $N$.
Hence, the emptiness problem is essentially equivalent to $\PNCOV$ and inherits its complexity, \ie it is $\EXPSPACE$-complete.

In the following, we want to derive that the \emph{word problem} for Petri net coverability languages is also $\EXPSPACE$-complete.

\begin{problem}
    \problemtitle{Word problem for Petri net coverability languages}
    \problemshort{($\WORDPNCOV$)}
    \probleminput{Labeled Petri net instance $(N, \Minit, \Mfinal)$ over $\Sigma$, word $w \in \Sigma^*$.}
    \problemquestion{$w \in \lang{N,\Minit,\Mfinal}$?}
\end{problem}

Hardness can be easily derived from the hardness of coverability:
A normal Petri net can be equipped with the labeling that maps all transitions to $\eps$.
The language of this labeled Petri net contains the word $\eps$ if and only if the final marking is coverable from the initial one.

For membership, we first explain how to intersect two Petri net coverability languages.
Similar to the construction for LTSes, we do this via some sort of product.
Unlike in the case of general LTSes, Petri nets have inherent support for concurrency, so we can form the product by taking the disjoint union of places.

For the formal definition, let $N = (P,T,\i,\o,\lambda), N' = (P,T',\i',\o',\lambda')$ be labeled Petri nets over the same alphabet $\Sigma$.
Assume $P \cap P' = \emptyset$, $T \cap T' = \emptyset$.
The \emph{synchronized product} $N \times N'$ of $N$ and $N'$ is the Petri net
\[
    N \times N' = (P \dotcup P', T_\times, \i_\times, \o_\times,\lambda_\times)
\]
with $T_\times = \Set{ (t,t') }{ t \in T, t' \in T, \lambda(t) = \lambda'(t') \in \Sigma} \cup \Set{ t }{ t \in T, \lambda(t) = \eps} \cup \Set{ t' }{ t' \in T, \lambda'(t') = \eps}$.
The transitions of shape $(t,t')$ behave as $t$ on the $P$-components of markings and as $t'$ on the $P'$-components.
Formally, ${(\i_\times (t,t'))}_{\restriction_P} = \i(t)$, similar for $P'$ and similar for $\o$.
The $\eps$-labeled transitions behave on the net they come from as before and have no effect on the places of the other net, \eg for $t \in T$ with $\lambda(t) = \eps$, we have $\i_\times(t,p) = \i(t,p)$ for $p \in P$, and $\i_\times(t,p') = 0$ \nb{for $p' \in P'$}.
The labeling of the transitions is as expected: \nb{$\lambda_\times (t,t') = \lambda(t) = \lambda'(t)$, $\lambda_\times(t) = \eps$, $\lambda_\times (t') = \eps$.}

For two labeled Petri net instances $(N,\Minit,\Mfinal)$,  $(N',\Minit',\Mfinal')$ over the same alphabet, their synchronized product is
\(
    (N \times N',M_{\init\times},M_{\final\times})
\)
where $M_{\init\times}$ is equal to $\Minit$ on $P$ and equal to $\Minit'$ on $P'$, similar for $M_{\final\times}$.

Intuitively, non-$\eps$-labeled transitions of $N$ and $N'$ have to synchronize in $N \times N'$, while $\eps$-labeled transitions can be fired freely.
This corresponds to the definition of the synchronized product for LTSes in \cref{Section:LTS}.
Indeed, the LTS associated to the synchronized product of two Petri nets is exactly the synchronized product of the LTSes associated to the nets.
In particular, we obtain that the language of the product is the intersection of the languages as desired,
\[
    \lang{N \times N',M_{\init\times},M_{\final\times}}
    = \lang{N,\Minit,\Mfinal} \cap \lang{N',\Minit',\Mfinal'}
    \ .
\]
To obtain an $\EXPSPACE$ algorithm for $\WORDPNCOV$, we see the input word $w$ as an NFA $A_w$ with $\lang{A_w} = \set{w}$.
As in \cref{Example:RegularPNCOV}, we can see this automaton in turn as a labeled Petri net instance $(N_w,M_{\init w},M_{\final w})$.
Using the previous lemma, we have that $w \in \lang{N,\Minit,\Mfinal}$ iff the language of the product of $(N,\Minit,\Mfinal)$ and $(N_w,M_{\init w},M_{\final w})$ is non-empty.
Since the size of this product is polynomial in the sum of the input sizes (that is, the size of the net and the size of $w$), applying the $\EXPSPACE$ algorithm for coverability yields the desired complexity.


\paragraph{Two useful approximations}

We have seen that a Petri net coverability language is not regular in general.
In the following, we define both a regular underapproximation and a regular overapproximation of such a language.
The approximations are parametric in a number $k$ that determines their precision.
Later in the thesis, we will see that by choosing $k$ appropriately, certain structural properties will carry over from the Petri net language to its approximation.

\paragraph{The length-approximation}

For a Petri net language $\lang{N,\Minit,\Mfinal}$, we define its \emph{length-$k$ approximation} by only considering firing sequences of length at most $k$:
\[
    \languak{k}{N,\Minit,\Mfinal}
    =
    \Set{ \lambda(\sigma) }{ \Minit \fire{\sigma} M \geq \Mfinal, \card{\sigma} \leq k}
    \ .
\]
% We note that the symbol $\sigma$ in $\languak{\sigma \leq k}{N,\Minit,\Mfinal}$ is just a part of the notation.
This language is an underapproximation, since $\languak{k}{N,\Minit,\Mfinal} \subseteq \lang{N,\Minit,\Mfinal}$ holds for any $k$.
It is also not hard to observe that $\languak{k}{N,\Minit,\Mfinal}$ is regular, and its state complexity is exponential in $n$, the size of $(N,\Minit,\Mfinal)$.

\begin{proposition}%
\label{Proposition:PNLengthkApprox}%
    For each $k$, $\languak{k}{N,\Minit,\Mfinal}$ is a regular language of state complexity at most $\bigO{k^n \cdot 2^{n^2}}$, where $n$ is the size of the binary encoding of $(N,\Minit,\Mfinal)$.
\end{proposition}

\begin{proof}
    We construct an NFA that simulates $N$ for $k$ steps.
    The NFA is $A = (Q,\to,q_\init,Q_F)$, where $Q = \zeroto{k} \times (P \to \zeroto{(k+1) \cdot 2^n})$, \ie a state is of the shape $(j,M)$, where $j$ is the number of steps that have been taken and $M$ is a marking that assigns at most $(k+1) \cdot 2^n$ tokens to each place.
    The initial state is $(0,\Minit)$, a state $(j,M)$ is final if $M \geq \Mfinal$.
    There is a transition from $(j,M)$ to $(j',M')$, labeled by $a$, if $j' = j+1 \leq k$ and in $N$, there is a transition $t$ such that $M \fire{t} M'$ with $\lambda(t) = a$.

    It is obvious that $A$ indeed simulates precisely the covering computations induced by firing sequences of length at most $k$.
    The maximum number that we can encode with $n$ bits is $2^n$, so a Petri net instance of size $n$ can add at most $2^n$ tokens to each place per transition.
    Since we perform at most $k$ transitions, each reachable state $(j,M)$ has $M(p) \leq \Minit(p) + k \cdot 2^n \leq (k+1) \cdot 2^n$, \ie we stay within the bounded state space.

    To prove the statement on the state complexity, we count the number of states of $A$:
    \[
        \card{Q}
        = (k+1) \cdot {(((k+1) \cdot 2^n) + 1)}^{\card{P}}
        \leq
        (k+1) \cdot {( 2 \cdot (k+1) \cdot 2^n)}^n
        \leq 2k \cdot 2^n \cdot 2^{2n} \cdot k^n \cdot {(2^n)}^n
        \in \bigO{k^n \cdot 2^{n^2}}
        \ .
    \]
\end{proof}

\paragraph{The $\omega$-approximation}

In addition to the above underapproximation, we also define a regular overapproximation of a Petri net language.
It only tracks the token count on each place up to a bound $k$ that is the parameter of the approximation.
If the token count ever exceeds $k$, the value of the place is set to $\omega$ (read as: unbounded) and remains so for the rest of the computations.
All transitions are enabled with respect to places that have become unbounded.

More formally, a \emph{generalized marking} is a vector $M \in \N_\omega^P$ with entries in $\N_\omega = \N \dotcup \set{\omega}$.
We extend the order to generalized markings by setting $x \leq \omega$ for all $x \in \N_\omega$.
Furthermore, we define $\omega + n = \omega - n = \omega$ for all $n \in \N$.
The firing relation extends to generalized markings in the natural way: Transition $t$ is enabled in $M$ if $M \geq \i(t)$, and firing it yields $M + e(t)$.
Note that $\i(t), \o(t)$ and $e(t)$ are vectors over the integers, so there is no need to define the values of $\omega + \omega$ and $\omega - \omega$.

For a number $k \in \N$, we define the \emph{$\zeroto{k}$-$\omega$-approximation} of a Petri net \nb{instance $(N,\Minit,\Mfinal)$} as the finite automaton $A_{> k}$ with state space ${(\zeroto{k} \cup \set{\omega} )}^P$.
Its initial state is the marking $\Minit'$ with $\Minit' (p) = \Minit(p)$ if $\Minit(p) \leq k$ and $\Minit'(p) = \omega$ else, and the final states are $\Set{ M \in {(\zeroto{k} \cup \set{\omega} )}^P  }{M \geq \Mfinal}$.
Its transition relation is induced by the firing relation of $N$:
We have $M \tow{a} M'$ if there is an $a$-labeled transition of $N$ such that $M \fire{a} M''$ with $M'(p) = M''(p)$ if $M''(p) \leq k$ and $M'(p) = \omega$ else.
The \emph{$\zeroto{k}$-$\omega$-approximation} $\langoak{k}{N,\Minit,\Mfinal}$ of a Petri net language $\lang{N,\Minit,\Mfinal}$ is defined to be the language of $A_{>k}$.

\begin{lemma}%
\label{Lemma:PNOverapproximation}%
    For each $k$, $\langoak{k}{N,\Minit,\Mfinal}$ is a regular overapproximation of $\lang{N,\Minit,\Mfinal}$ with state complexity at most $2^n k^n$, where $n$ is the size of $(N,\Minit,\Mfinal)$.
\end{lemma}

\begin{proof}
    Language $\langoak{k}{N,\Minit,\Mfinal}$ is trivially regular since it is defined by a finite automaton.
    Observe that any covering computation of $N$ induces an accepting run of $A_{> k}$ generating the same word, so $\lang{N,\Minit,\Mfinal} \subseteq \langoak{k}{N,\Minit,\Mfinal}$ holds.
    For the state complexity, note that the number of generalized markings in which the natural entries are bounded by $k$ (for $k \geq 2$) is
    \[
        \card{ {(\zeroto{k} \cup \set{\omega} )}^P }
        = {(k+2)}^P
        \leq 2^n k^n
        \ .
    \]
\end{proof}

\end{document}
