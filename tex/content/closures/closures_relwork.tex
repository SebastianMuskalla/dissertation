\documentclass[../../diss.tex]{subfiles}
\begin{document}

\section{Related work}%
\label{Section:PNRelwork}%

The fact that closures of languages are regular, but their representations cannot always be computed, has motivated research to study for which classes of languages the closures are effectively regular.
For some classes that have this property, studies have determined the optimal size of NFAs representing the closures.
This size is important:
If we use an NFA representing a closure as the input to a decision problem, then the running time of solving that problem will scale with the size of the automaton.

We present some simple examples before citing more involved results from the literature.

For a regular language $\calL = \lang{A}$, represented by an NFA $A$, it is easy to compute NFAs $\dc{A}$ and $\uc{A}$ with $\lang{\dc{A}} = \dc{\calL}$ and $\lang{\uc{A}} = \uc{\calL}$, respectively.
Note that the arrow in $\dc{A}$ is part of the notation and does not denote a closure, similar for $\uc{A}$.
To construct $\dc{A}$, we add for each transition $q \tow{a} p$ of $A$ that is labeled by a symbol $a \in \Sigma$ an $\eps$-labeled version of this transition, $q \tow{\eps} p$.
By using these transitions, it is easy to show that any subword of a word in the language of $A$ has an accepting run in $\dc{A}$.
For the construction of $\uc{A}$, we mimic the proof of \cref{Theorem:Haines} by allowing the insertion of arbitrary words.
To be more precise, for each state $q$ and each \nb{letter $a \in \Sigma$}, we add a loop $q \tow{a} q$ to automaton $A$.

Alternatively, one could construct a representation of $\uc{\calL}$ by complementing $\calL$, computing the downward closure, and complementing again.
However, this approach does not work for classes of languages for which the complement cannot be effectively constructed.
In general, the computability of the upward closure and the computability of the downward closure are distinct problems that have to be studied separately.

The construction that we have used for NFAs translates into similar constructions for Petri nets and context-free grammars.
Given a Petri net $N$, we can construct a Petri net $\dc{N}$ by adding for each transition an $\eps$-labeled version.
Similarly, we construct $\uc{N}$ by adding for each letter $a$ an $a$-labeled spontaneous transition that does not produce any tokens, \ie a transition $t$ with $\i(t) = \o(t) = \vec{0}$.
We obtain that $\lang{\dc{N},\Minit,\Mfinal} = \dc{\lang{N,\Minit,\Mfinal}}$ for all markings $\Minit, \Mfinal$, similar for the upward closure.
The constructions for context-free grammars are similar and realize the downward closure by being able to omit letters and the upward closure by allowing the insertion of arbitrary words.

While these constructions are simple and sometimes even useful -- we will use the Petri net $\dc{N}$ in several proofs later in this part of the thesis --  they do not yield the desired result.
For example, $\dc{N}$ is a Petri net that represents the downward closure of $N$, but it is not a regular representation, \ie an NFA or a regular expression.
It may be hard or even impossible to construct an algorithm that transform a non-regular representation for some input language $\calL$ into a regular representation, even when knowing that the input language is regular.

For the languages generated by context-free grammars, the computability of the downward and upward closure has been studied in~\cite{vanLeeuwen78,Courcelle91,GruberHK07,BachmeierLS15}.
The effective regularity has been first proven in~\cite{vanLeeuwen78}.
The paper~\cite{GruberHK07} shows that for a context-free grammar of size $n$, the state complexity of the upward closure is at most $2^{\bigO{n}}$, \ie one can compute an NFA with at most $2^{\bigO{n}}$ states representing the upward closure.
The same upper bound on the state complexity was proven~\cite{BachmeierLS15} for the downward closure.
Additionally,~\cite{BachmeierLS15} present a family of finite languages that show that the aforementioned upper bounds are in fact optimal.

For the languages of one-counter automata, a strict subclass of the class of context-free languages, finite automata representing the downward and upward closure of the language can be computed in polynomial time~\cite{AtigCHKSZ16}.
% The effective computability of the downward closure has also been shown for stacked counter automata~\cite{Zetzsche15a}.

In~\cite{Zetzsche15b}, Zetzsche has shown that for any class of languages that is a \emph{full trio}, \ie it satisfies certain closure properties, the computability of the downward closure is equivalent to the decidability of a \emph{simultaneous unbounded problem}.
In his paper, he applies this result to show that the downward closures of \emph{indexed languages}, the languages of higher-order pushdown automata of order 2, are computable.
Later, the result has been used to prove the effective computability of the downward closures of higher-order pushdown automata and higher-order recursion schemes of arbitrary order~\cite{HagueKO16,ClementePSW16}.

The case of Petri net languages has been considered in~\cite{HabermehlMW10}.
In addition to the general case of reachability as the acceptance condition, the paper contains a construction specifically for coverability languages.
In contrast to the general case, this construction does not rely on details from Lambert's proof of decidability of Petri net reachability~\cite{Lambert92}, but only on the well-known Karp-Miller tree~\cite{KarpM69}.
However, the size of the Karp-Miller tree is known to be non-primitive recursive in the worst case, and the paper leaves the question of whether a smaller construction exists unanswered.

We conclude this section with a negative example: The downward closures of the languages of lossy channel systems are not computable.
A \emph{lossy channel system (LCS)} consists of several finite-state components that communicate by writing to and reading from FIFO (first in, first out) channels.
To avoid the undecidability of the Turing-complete model of \emph{perfect channel systems}, the channels are lossy.
This means that in each step of the computation, the content $w$ of some channel can be replaced by some $v$ with $v \subword w$.
LCSes are captured by the framework of WSTSes, which in particular means that reachability is decidable.
However, many other problems that are decidable for other WSTSes like Petri nets are undecidable, as proven in~\cite{Mayr03}.
In addition to repeated reachability, this also includes the unboundedness problem, \ie the problem of deciding whether there is a constant bounding the length of the content of all channels.
It is easy to design an LCS that at some point stops its computation, selects one channel, and generates (a subword of) the current content of this channel as a word.
Assuming that one could compute an NFA representing the downward closure of the language of this LCS, one could check whether the channel content of the original LCS is bounded.
Hence, the undecidability of the boundedness problem means that downward closures are not effectively regular for LCSes.

\end{document}
